// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/vmware-tanzu/carvel-kapp-controller/pkg/apis/installpackage/v1alpha1"
	v1alpha1a "github.com/vmware-tanzu/carvel-kapp-controller/pkg/apis/kappctrl/v1alpha1"
	v1alpha1b "github.com/vmware-tanzu/carvel-kapp-controller/pkg/apiserver/apis/packages/v1alpha1"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/vmware-tanzu-private/core/pkg/v1/tkg/kappclient"
)

type KappClient struct {
	CreateInstalledPackageStub        func(*v1alpha1.InstalledPackage, bool, bool) error
	createInstalledPackageMutex       sync.RWMutex
	createInstalledPackageArgsForCall []struct {
		arg1 *v1alpha1.InstalledPackage
		arg2 bool
		arg3 bool
	}
	createInstalledPackageReturns struct {
		result1 error
	}
	createInstalledPackageReturnsOnCall map[int]struct {
		result1 error
	}
	CreatePackageRepositoryStub        func(*v1alpha1.PackageRepository) error
	createPackageRepositoryMutex       sync.RWMutex
	createPackageRepositoryArgsForCall []struct {
		arg1 *v1alpha1.PackageRepository
	}
	createPackageRepositoryReturns struct {
		result1 error
	}
	createPackageRepositoryReturnsOnCall map[int]struct {
		result1 error
	}
	DeletePackageRepositoryStub        func(*v1alpha1.PackageRepository) error
	deletePackageRepositoryMutex       sync.RWMutex
	deletePackageRepositoryArgsForCall []struct {
		arg1 *v1alpha1.PackageRepository
	}
	deletePackageRepositoryReturns struct {
		result1 error
	}
	deletePackageRepositoryReturnsOnCall map[int]struct {
		result1 error
	}
	GetAppCRStub        func(string, string) (*v1alpha1a.App, error)
	getAppCRMutex       sync.RWMutex
	getAppCRArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getAppCRReturns struct {
		result1 *v1alpha1a.App
		result2 error
	}
	getAppCRReturnsOnCall map[int]struct {
		result1 *v1alpha1a.App
		result2 error
	}
	GetClientStub        func() client.Client
	getClientMutex       sync.RWMutex
	getClientArgsForCall []struct {
	}
	getClientReturns struct {
		result1 client.Client
	}
	getClientReturnsOnCall map[int]struct {
		result1 client.Client
	}
	GetInstalledPackageStub        func(string, string) (*v1alpha1.InstalledPackage, error)
	getInstalledPackageMutex       sync.RWMutex
	getInstalledPackageArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getInstalledPackageReturns struct {
		result1 *v1alpha1.InstalledPackage
		result2 error
	}
	getInstalledPackageReturnsOnCall map[int]struct {
		result1 *v1alpha1.InstalledPackage
		result2 error
	}
	GetPackageByNameStub        func(string, string) (*v1alpha1b.Package, error)
	getPackageByNameMutex       sync.RWMutex
	getPackageByNameArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getPackageByNameReturns struct {
		result1 *v1alpha1b.Package
		result2 error
	}
	getPackageByNameReturnsOnCall map[int]struct {
		result1 *v1alpha1b.Package
		result2 error
	}
	GetPackageRepositoryStub        func(string) (*v1alpha1.PackageRepository, error)
	getPackageRepositoryMutex       sync.RWMutex
	getPackageRepositoryArgsForCall []struct {
		arg1 string
	}
	getPackageRepositoryReturns struct {
		result1 *v1alpha1.PackageRepository
		result2 error
	}
	getPackageRepositoryReturnsOnCall map[int]struct {
		result1 *v1alpha1.PackageRepository
		result2 error
	}
	ListInstalledPackagesStub        func(string) (*v1alpha1.InstalledPackageList, error)
	listInstalledPackagesMutex       sync.RWMutex
	listInstalledPackagesArgsForCall []struct {
		arg1 string
	}
	listInstalledPackagesReturns struct {
		result1 *v1alpha1.InstalledPackageList
		result2 error
	}
	listInstalledPackagesReturnsOnCall map[int]struct {
		result1 *v1alpha1.InstalledPackageList
		result2 error
	}
	ListPackageRepositoriesStub        func() (*v1alpha1.PackageRepositoryList, error)
	listPackageRepositoriesMutex       sync.RWMutex
	listPackageRepositoriesArgsForCall []struct {
	}
	listPackageRepositoriesReturns struct {
		result1 *v1alpha1.PackageRepositoryList
		result2 error
	}
	listPackageRepositoriesReturnsOnCall map[int]struct {
		result1 *v1alpha1.PackageRepositoryList
		result2 error
	}
	ListPackageVersionsStub        func(string, string) (*v1alpha1b.PackageVersionList, error)
	listPackageVersionsMutex       sync.RWMutex
	listPackageVersionsArgsForCall []struct {
		arg1 string
		arg2 string
	}
	listPackageVersionsReturns struct {
		result1 *v1alpha1b.PackageVersionList
		result2 error
	}
	listPackageVersionsReturnsOnCall map[int]struct {
		result1 *v1alpha1b.PackageVersionList
		result2 error
	}
	ListPackagesStub        func() (*v1alpha1b.PackageList, error)
	listPackagesMutex       sync.RWMutex
	listPackagesArgsForCall []struct {
	}
	listPackagesReturns struct {
		result1 *v1alpha1b.PackageList
		result2 error
	}
	listPackagesReturnsOnCall map[int]struct {
		result1 *v1alpha1b.PackageList
		result2 error
	}
	UpdatePackageRepositoryStub        func(*v1alpha1.PackageRepository) error
	updatePackageRepositoryMutex       sync.RWMutex
	updatePackageRepositoryArgsForCall []struct {
		arg1 *v1alpha1.PackageRepository
	}
	updatePackageRepositoryReturns struct {
		result1 error
	}
	updatePackageRepositoryReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *KappClient) CreateInstalledPackage(arg1 *v1alpha1.InstalledPackage, arg2 bool, arg3 bool) error {
	fake.createInstalledPackageMutex.Lock()
	ret, specificReturn := fake.createInstalledPackageReturnsOnCall[len(fake.createInstalledPackageArgsForCall)]
	fake.createInstalledPackageArgsForCall = append(fake.createInstalledPackageArgsForCall, struct {
		arg1 *v1alpha1.InstalledPackage
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("CreateInstalledPackage", []interface{}{arg1, arg2, arg3})
	fake.createInstalledPackageMutex.Unlock()
	if fake.CreateInstalledPackageStub != nil {
		return fake.CreateInstalledPackageStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createInstalledPackageReturns
	return fakeReturns.result1
}

func (fake *KappClient) CreateInstalledPackageCallCount() int {
	fake.createInstalledPackageMutex.RLock()
	defer fake.createInstalledPackageMutex.RUnlock()
	return len(fake.createInstalledPackageArgsForCall)
}

func (fake *KappClient) CreateInstalledPackageCalls(stub func(*v1alpha1.InstalledPackage, bool, bool) error) {
	fake.createInstalledPackageMutex.Lock()
	defer fake.createInstalledPackageMutex.Unlock()
	fake.CreateInstalledPackageStub = stub
}

func (fake *KappClient) CreateInstalledPackageArgsForCall(i int) (*v1alpha1.InstalledPackage, bool, bool) {
	fake.createInstalledPackageMutex.RLock()
	defer fake.createInstalledPackageMutex.RUnlock()
	argsForCall := fake.createInstalledPackageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *KappClient) CreateInstalledPackageReturns(result1 error) {
	fake.createInstalledPackageMutex.Lock()
	defer fake.createInstalledPackageMutex.Unlock()
	fake.CreateInstalledPackageStub = nil
	fake.createInstalledPackageReturns = struct {
		result1 error
	}{result1}
}

func (fake *KappClient) CreateInstalledPackageReturnsOnCall(i int, result1 error) {
	fake.createInstalledPackageMutex.Lock()
	defer fake.createInstalledPackageMutex.Unlock()
	fake.CreateInstalledPackageStub = nil
	if fake.createInstalledPackageReturnsOnCall == nil {
		fake.createInstalledPackageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createInstalledPackageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *KappClient) CreatePackageRepository(arg1 *v1alpha1.PackageRepository) error {
	fake.createPackageRepositoryMutex.Lock()
	ret, specificReturn := fake.createPackageRepositoryReturnsOnCall[len(fake.createPackageRepositoryArgsForCall)]
	fake.createPackageRepositoryArgsForCall = append(fake.createPackageRepositoryArgsForCall, struct {
		arg1 *v1alpha1.PackageRepository
	}{arg1})
	fake.recordInvocation("CreatePackageRepository", []interface{}{arg1})
	fake.createPackageRepositoryMutex.Unlock()
	if fake.CreatePackageRepositoryStub != nil {
		return fake.CreatePackageRepositoryStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createPackageRepositoryReturns
	return fakeReturns.result1
}

func (fake *KappClient) CreatePackageRepositoryCallCount() int {
	fake.createPackageRepositoryMutex.RLock()
	defer fake.createPackageRepositoryMutex.RUnlock()
	return len(fake.createPackageRepositoryArgsForCall)
}

func (fake *KappClient) CreatePackageRepositoryCalls(stub func(*v1alpha1.PackageRepository) error) {
	fake.createPackageRepositoryMutex.Lock()
	defer fake.createPackageRepositoryMutex.Unlock()
	fake.CreatePackageRepositoryStub = stub
}

func (fake *KappClient) CreatePackageRepositoryArgsForCall(i int) *v1alpha1.PackageRepository {
	fake.createPackageRepositoryMutex.RLock()
	defer fake.createPackageRepositoryMutex.RUnlock()
	argsForCall := fake.createPackageRepositoryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KappClient) CreatePackageRepositoryReturns(result1 error) {
	fake.createPackageRepositoryMutex.Lock()
	defer fake.createPackageRepositoryMutex.Unlock()
	fake.CreatePackageRepositoryStub = nil
	fake.createPackageRepositoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *KappClient) CreatePackageRepositoryReturnsOnCall(i int, result1 error) {
	fake.createPackageRepositoryMutex.Lock()
	defer fake.createPackageRepositoryMutex.Unlock()
	fake.CreatePackageRepositoryStub = nil
	if fake.createPackageRepositoryReturnsOnCall == nil {
		fake.createPackageRepositoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createPackageRepositoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *KappClient) DeletePackageRepository(arg1 *v1alpha1.PackageRepository) error {
	fake.deletePackageRepositoryMutex.Lock()
	ret, specificReturn := fake.deletePackageRepositoryReturnsOnCall[len(fake.deletePackageRepositoryArgsForCall)]
	fake.deletePackageRepositoryArgsForCall = append(fake.deletePackageRepositoryArgsForCall, struct {
		arg1 *v1alpha1.PackageRepository
	}{arg1})
	fake.recordInvocation("DeletePackageRepository", []interface{}{arg1})
	fake.deletePackageRepositoryMutex.Unlock()
	if fake.DeletePackageRepositoryStub != nil {
		return fake.DeletePackageRepositoryStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deletePackageRepositoryReturns
	return fakeReturns.result1
}

func (fake *KappClient) DeletePackageRepositoryCallCount() int {
	fake.deletePackageRepositoryMutex.RLock()
	defer fake.deletePackageRepositoryMutex.RUnlock()
	return len(fake.deletePackageRepositoryArgsForCall)
}

func (fake *KappClient) DeletePackageRepositoryCalls(stub func(*v1alpha1.PackageRepository) error) {
	fake.deletePackageRepositoryMutex.Lock()
	defer fake.deletePackageRepositoryMutex.Unlock()
	fake.DeletePackageRepositoryStub = stub
}

func (fake *KappClient) DeletePackageRepositoryArgsForCall(i int) *v1alpha1.PackageRepository {
	fake.deletePackageRepositoryMutex.RLock()
	defer fake.deletePackageRepositoryMutex.RUnlock()
	argsForCall := fake.deletePackageRepositoryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KappClient) DeletePackageRepositoryReturns(result1 error) {
	fake.deletePackageRepositoryMutex.Lock()
	defer fake.deletePackageRepositoryMutex.Unlock()
	fake.DeletePackageRepositoryStub = nil
	fake.deletePackageRepositoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *KappClient) DeletePackageRepositoryReturnsOnCall(i int, result1 error) {
	fake.deletePackageRepositoryMutex.Lock()
	defer fake.deletePackageRepositoryMutex.Unlock()
	fake.DeletePackageRepositoryStub = nil
	if fake.deletePackageRepositoryReturnsOnCall == nil {
		fake.deletePackageRepositoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deletePackageRepositoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *KappClient) GetAppCR(arg1 string, arg2 string) (*v1alpha1a.App, error) {
	fake.getAppCRMutex.Lock()
	ret, specificReturn := fake.getAppCRReturnsOnCall[len(fake.getAppCRArgsForCall)]
	fake.getAppCRArgsForCall = append(fake.getAppCRArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetAppCR", []interface{}{arg1, arg2})
	fake.getAppCRMutex.Unlock()
	if fake.GetAppCRStub != nil {
		return fake.GetAppCRStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAppCRReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KappClient) GetAppCRCallCount() int {
	fake.getAppCRMutex.RLock()
	defer fake.getAppCRMutex.RUnlock()
	return len(fake.getAppCRArgsForCall)
}

func (fake *KappClient) GetAppCRCalls(stub func(string, string) (*v1alpha1a.App, error)) {
	fake.getAppCRMutex.Lock()
	defer fake.getAppCRMutex.Unlock()
	fake.GetAppCRStub = stub
}

func (fake *KappClient) GetAppCRArgsForCall(i int) (string, string) {
	fake.getAppCRMutex.RLock()
	defer fake.getAppCRMutex.RUnlock()
	argsForCall := fake.getAppCRArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *KappClient) GetAppCRReturns(result1 *v1alpha1a.App, result2 error) {
	fake.getAppCRMutex.Lock()
	defer fake.getAppCRMutex.Unlock()
	fake.GetAppCRStub = nil
	fake.getAppCRReturns = struct {
		result1 *v1alpha1a.App
		result2 error
	}{result1, result2}
}

func (fake *KappClient) GetAppCRReturnsOnCall(i int, result1 *v1alpha1a.App, result2 error) {
	fake.getAppCRMutex.Lock()
	defer fake.getAppCRMutex.Unlock()
	fake.GetAppCRStub = nil
	if fake.getAppCRReturnsOnCall == nil {
		fake.getAppCRReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1a.App
			result2 error
		})
	}
	fake.getAppCRReturnsOnCall[i] = struct {
		result1 *v1alpha1a.App
		result2 error
	}{result1, result2}
}

func (fake *KappClient) GetClient() client.Client {
	fake.getClientMutex.Lock()
	ret, specificReturn := fake.getClientReturnsOnCall[len(fake.getClientArgsForCall)]
	fake.getClientArgsForCall = append(fake.getClientArgsForCall, struct {
	}{})
	fake.recordInvocation("GetClient", []interface{}{})
	fake.getClientMutex.Unlock()
	if fake.GetClientStub != nil {
		return fake.GetClientStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getClientReturns
	return fakeReturns.result1
}

func (fake *KappClient) GetClientCallCount() int {
	fake.getClientMutex.RLock()
	defer fake.getClientMutex.RUnlock()
	return len(fake.getClientArgsForCall)
}

func (fake *KappClient) GetClientCalls(stub func() client.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = stub
}

func (fake *KappClient) GetClientReturns(result1 client.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = nil
	fake.getClientReturns = struct {
		result1 client.Client
	}{result1}
}

func (fake *KappClient) GetClientReturnsOnCall(i int, result1 client.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = nil
	if fake.getClientReturnsOnCall == nil {
		fake.getClientReturnsOnCall = make(map[int]struct {
			result1 client.Client
		})
	}
	fake.getClientReturnsOnCall[i] = struct {
		result1 client.Client
	}{result1}
}

func (fake *KappClient) GetInstalledPackage(arg1 string, arg2 string) (*v1alpha1.InstalledPackage, error) {
	fake.getInstalledPackageMutex.Lock()
	ret, specificReturn := fake.getInstalledPackageReturnsOnCall[len(fake.getInstalledPackageArgsForCall)]
	fake.getInstalledPackageArgsForCall = append(fake.getInstalledPackageArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetInstalledPackage", []interface{}{arg1, arg2})
	fake.getInstalledPackageMutex.Unlock()
	if fake.GetInstalledPackageStub != nil {
		return fake.GetInstalledPackageStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getInstalledPackageReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KappClient) GetInstalledPackageCallCount() int {
	fake.getInstalledPackageMutex.RLock()
	defer fake.getInstalledPackageMutex.RUnlock()
	return len(fake.getInstalledPackageArgsForCall)
}

func (fake *KappClient) GetInstalledPackageCalls(stub func(string, string) (*v1alpha1.InstalledPackage, error)) {
	fake.getInstalledPackageMutex.Lock()
	defer fake.getInstalledPackageMutex.Unlock()
	fake.GetInstalledPackageStub = stub
}

func (fake *KappClient) GetInstalledPackageArgsForCall(i int) (string, string) {
	fake.getInstalledPackageMutex.RLock()
	defer fake.getInstalledPackageMutex.RUnlock()
	argsForCall := fake.getInstalledPackageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *KappClient) GetInstalledPackageReturns(result1 *v1alpha1.InstalledPackage, result2 error) {
	fake.getInstalledPackageMutex.Lock()
	defer fake.getInstalledPackageMutex.Unlock()
	fake.GetInstalledPackageStub = nil
	fake.getInstalledPackageReturns = struct {
		result1 *v1alpha1.InstalledPackage
		result2 error
	}{result1, result2}
}

func (fake *KappClient) GetInstalledPackageReturnsOnCall(i int, result1 *v1alpha1.InstalledPackage, result2 error) {
	fake.getInstalledPackageMutex.Lock()
	defer fake.getInstalledPackageMutex.Unlock()
	fake.GetInstalledPackageStub = nil
	if fake.getInstalledPackageReturnsOnCall == nil {
		fake.getInstalledPackageReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.InstalledPackage
			result2 error
		})
	}
	fake.getInstalledPackageReturnsOnCall[i] = struct {
		result1 *v1alpha1.InstalledPackage
		result2 error
	}{result1, result2}
}

func (fake *KappClient) GetPackageByName(arg1 string, arg2 string) (*v1alpha1b.Package, error) {
	fake.getPackageByNameMutex.Lock()
	ret, specificReturn := fake.getPackageByNameReturnsOnCall[len(fake.getPackageByNameArgsForCall)]
	fake.getPackageByNameArgsForCall = append(fake.getPackageByNameArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetPackageByName", []interface{}{arg1, arg2})
	fake.getPackageByNameMutex.Unlock()
	if fake.GetPackageByNameStub != nil {
		return fake.GetPackageByNameStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getPackageByNameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KappClient) GetPackageByNameCallCount() int {
	fake.getPackageByNameMutex.RLock()
	defer fake.getPackageByNameMutex.RUnlock()
	return len(fake.getPackageByNameArgsForCall)
}

func (fake *KappClient) GetPackageByNameCalls(stub func(string, string) (*v1alpha1b.Package, error)) {
	fake.getPackageByNameMutex.Lock()
	defer fake.getPackageByNameMutex.Unlock()
	fake.GetPackageByNameStub = stub
}

func (fake *KappClient) GetPackageByNameArgsForCall(i int) (string, string) {
	fake.getPackageByNameMutex.RLock()
	defer fake.getPackageByNameMutex.RUnlock()
	argsForCall := fake.getPackageByNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *KappClient) GetPackageByNameReturns(result1 *v1alpha1b.Package, result2 error) {
	fake.getPackageByNameMutex.Lock()
	defer fake.getPackageByNameMutex.Unlock()
	fake.GetPackageByNameStub = nil
	fake.getPackageByNameReturns = struct {
		result1 *v1alpha1b.Package
		result2 error
	}{result1, result2}
}

func (fake *KappClient) GetPackageByNameReturnsOnCall(i int, result1 *v1alpha1b.Package, result2 error) {
	fake.getPackageByNameMutex.Lock()
	defer fake.getPackageByNameMutex.Unlock()
	fake.GetPackageByNameStub = nil
	if fake.getPackageByNameReturnsOnCall == nil {
		fake.getPackageByNameReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1b.Package
			result2 error
		})
	}
	fake.getPackageByNameReturnsOnCall[i] = struct {
		result1 *v1alpha1b.Package
		result2 error
	}{result1, result2}
}

func (fake *KappClient) GetPackageRepository(arg1 string) (*v1alpha1.PackageRepository, error) {
	fake.getPackageRepositoryMutex.Lock()
	ret, specificReturn := fake.getPackageRepositoryReturnsOnCall[len(fake.getPackageRepositoryArgsForCall)]
	fake.getPackageRepositoryArgsForCall = append(fake.getPackageRepositoryArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetPackageRepository", []interface{}{arg1})
	fake.getPackageRepositoryMutex.Unlock()
	if fake.GetPackageRepositoryStub != nil {
		return fake.GetPackageRepositoryStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getPackageRepositoryReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KappClient) GetPackageRepositoryCallCount() int {
	fake.getPackageRepositoryMutex.RLock()
	defer fake.getPackageRepositoryMutex.RUnlock()
	return len(fake.getPackageRepositoryArgsForCall)
}

func (fake *KappClient) GetPackageRepositoryCalls(stub func(string) (*v1alpha1.PackageRepository, error)) {
	fake.getPackageRepositoryMutex.Lock()
	defer fake.getPackageRepositoryMutex.Unlock()
	fake.GetPackageRepositoryStub = stub
}

func (fake *KappClient) GetPackageRepositoryArgsForCall(i int) string {
	fake.getPackageRepositoryMutex.RLock()
	defer fake.getPackageRepositoryMutex.RUnlock()
	argsForCall := fake.getPackageRepositoryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KappClient) GetPackageRepositoryReturns(result1 *v1alpha1.PackageRepository, result2 error) {
	fake.getPackageRepositoryMutex.Lock()
	defer fake.getPackageRepositoryMutex.Unlock()
	fake.GetPackageRepositoryStub = nil
	fake.getPackageRepositoryReturns = struct {
		result1 *v1alpha1.PackageRepository
		result2 error
	}{result1, result2}
}

func (fake *KappClient) GetPackageRepositoryReturnsOnCall(i int, result1 *v1alpha1.PackageRepository, result2 error) {
	fake.getPackageRepositoryMutex.Lock()
	defer fake.getPackageRepositoryMutex.Unlock()
	fake.GetPackageRepositoryStub = nil
	if fake.getPackageRepositoryReturnsOnCall == nil {
		fake.getPackageRepositoryReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.PackageRepository
			result2 error
		})
	}
	fake.getPackageRepositoryReturnsOnCall[i] = struct {
		result1 *v1alpha1.PackageRepository
		result2 error
	}{result1, result2}
}

func (fake *KappClient) ListInstalledPackages(arg1 string) (*v1alpha1.InstalledPackageList, error) {
	fake.listInstalledPackagesMutex.Lock()
	ret, specificReturn := fake.listInstalledPackagesReturnsOnCall[len(fake.listInstalledPackagesArgsForCall)]
	fake.listInstalledPackagesArgsForCall = append(fake.listInstalledPackagesArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ListInstalledPackages", []interface{}{arg1})
	fake.listInstalledPackagesMutex.Unlock()
	if fake.ListInstalledPackagesStub != nil {
		return fake.ListInstalledPackagesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listInstalledPackagesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KappClient) ListInstalledPackagesCallCount() int {
	fake.listInstalledPackagesMutex.RLock()
	defer fake.listInstalledPackagesMutex.RUnlock()
	return len(fake.listInstalledPackagesArgsForCall)
}

func (fake *KappClient) ListInstalledPackagesCalls(stub func(string) (*v1alpha1.InstalledPackageList, error)) {
	fake.listInstalledPackagesMutex.Lock()
	defer fake.listInstalledPackagesMutex.Unlock()
	fake.ListInstalledPackagesStub = stub
}

func (fake *KappClient) ListInstalledPackagesArgsForCall(i int) string {
	fake.listInstalledPackagesMutex.RLock()
	defer fake.listInstalledPackagesMutex.RUnlock()
	argsForCall := fake.listInstalledPackagesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KappClient) ListInstalledPackagesReturns(result1 *v1alpha1.InstalledPackageList, result2 error) {
	fake.listInstalledPackagesMutex.Lock()
	defer fake.listInstalledPackagesMutex.Unlock()
	fake.ListInstalledPackagesStub = nil
	fake.listInstalledPackagesReturns = struct {
		result1 *v1alpha1.InstalledPackageList
		result2 error
	}{result1, result2}
}

func (fake *KappClient) ListInstalledPackagesReturnsOnCall(i int, result1 *v1alpha1.InstalledPackageList, result2 error) {
	fake.listInstalledPackagesMutex.Lock()
	defer fake.listInstalledPackagesMutex.Unlock()
	fake.ListInstalledPackagesStub = nil
	if fake.listInstalledPackagesReturnsOnCall == nil {
		fake.listInstalledPackagesReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.InstalledPackageList
			result2 error
		})
	}
	fake.listInstalledPackagesReturnsOnCall[i] = struct {
		result1 *v1alpha1.InstalledPackageList
		result2 error
	}{result1, result2}
}

func (fake *KappClient) ListPackageRepositories() (*v1alpha1.PackageRepositoryList, error) {
	fake.listPackageRepositoriesMutex.Lock()
	ret, specificReturn := fake.listPackageRepositoriesReturnsOnCall[len(fake.listPackageRepositoriesArgsForCall)]
	fake.listPackageRepositoriesArgsForCall = append(fake.listPackageRepositoriesArgsForCall, struct {
	}{})
	fake.recordInvocation("ListPackageRepositories", []interface{}{})
	fake.listPackageRepositoriesMutex.Unlock()
	if fake.ListPackageRepositoriesStub != nil {
		return fake.ListPackageRepositoriesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listPackageRepositoriesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KappClient) ListPackageRepositoriesCallCount() int {
	fake.listPackageRepositoriesMutex.RLock()
	defer fake.listPackageRepositoriesMutex.RUnlock()
	return len(fake.listPackageRepositoriesArgsForCall)
}

func (fake *KappClient) ListPackageRepositoriesCalls(stub func() (*v1alpha1.PackageRepositoryList, error)) {
	fake.listPackageRepositoriesMutex.Lock()
	defer fake.listPackageRepositoriesMutex.Unlock()
	fake.ListPackageRepositoriesStub = stub
}

func (fake *KappClient) ListPackageRepositoriesReturns(result1 *v1alpha1.PackageRepositoryList, result2 error) {
	fake.listPackageRepositoriesMutex.Lock()
	defer fake.listPackageRepositoriesMutex.Unlock()
	fake.ListPackageRepositoriesStub = nil
	fake.listPackageRepositoriesReturns = struct {
		result1 *v1alpha1.PackageRepositoryList
		result2 error
	}{result1, result2}
}

func (fake *KappClient) ListPackageRepositoriesReturnsOnCall(i int, result1 *v1alpha1.PackageRepositoryList, result2 error) {
	fake.listPackageRepositoriesMutex.Lock()
	defer fake.listPackageRepositoriesMutex.Unlock()
	fake.ListPackageRepositoriesStub = nil
	if fake.listPackageRepositoriesReturnsOnCall == nil {
		fake.listPackageRepositoriesReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.PackageRepositoryList
			result2 error
		})
	}
	fake.listPackageRepositoriesReturnsOnCall[i] = struct {
		result1 *v1alpha1.PackageRepositoryList
		result2 error
	}{result1, result2}
}

func (fake *KappClient) ListPackageVersions(arg1 string, arg2 string) (*v1alpha1b.PackageVersionList, error) {
	fake.listPackageVersionsMutex.Lock()
	ret, specificReturn := fake.listPackageVersionsReturnsOnCall[len(fake.listPackageVersionsArgsForCall)]
	fake.listPackageVersionsArgsForCall = append(fake.listPackageVersionsArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ListPackageVersions", []interface{}{arg1, arg2})
	fake.listPackageVersionsMutex.Unlock()
	if fake.ListPackageVersionsStub != nil {
		return fake.ListPackageVersionsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listPackageVersionsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KappClient) ListPackageVersionsCallCount() int {
	fake.listPackageVersionsMutex.RLock()
	defer fake.listPackageVersionsMutex.RUnlock()
	return len(fake.listPackageVersionsArgsForCall)
}

func (fake *KappClient) ListPackageVersionsCalls(stub func(string, string) (*v1alpha1b.PackageVersionList, error)) {
	fake.listPackageVersionsMutex.Lock()
	defer fake.listPackageVersionsMutex.Unlock()
	fake.ListPackageVersionsStub = stub
}

func (fake *KappClient) ListPackageVersionsArgsForCall(i int) (string, string) {
	fake.listPackageVersionsMutex.RLock()
	defer fake.listPackageVersionsMutex.RUnlock()
	argsForCall := fake.listPackageVersionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *KappClient) ListPackageVersionsReturns(result1 *v1alpha1b.PackageVersionList, result2 error) {
	fake.listPackageVersionsMutex.Lock()
	defer fake.listPackageVersionsMutex.Unlock()
	fake.ListPackageVersionsStub = nil
	fake.listPackageVersionsReturns = struct {
		result1 *v1alpha1b.PackageVersionList
		result2 error
	}{result1, result2}
}

func (fake *KappClient) ListPackageVersionsReturnsOnCall(i int, result1 *v1alpha1b.PackageVersionList, result2 error) {
	fake.listPackageVersionsMutex.Lock()
	defer fake.listPackageVersionsMutex.Unlock()
	fake.ListPackageVersionsStub = nil
	if fake.listPackageVersionsReturnsOnCall == nil {
		fake.listPackageVersionsReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1b.PackageVersionList
			result2 error
		})
	}
	fake.listPackageVersionsReturnsOnCall[i] = struct {
		result1 *v1alpha1b.PackageVersionList
		result2 error
	}{result1, result2}
}

func (fake *KappClient) ListPackages() (*v1alpha1b.PackageList, error) {
	fake.listPackagesMutex.Lock()
	ret, specificReturn := fake.listPackagesReturnsOnCall[len(fake.listPackagesArgsForCall)]
	fake.listPackagesArgsForCall = append(fake.listPackagesArgsForCall, struct {
	}{})
	fake.recordInvocation("ListPackages", []interface{}{})
	fake.listPackagesMutex.Unlock()
	if fake.ListPackagesStub != nil {
		return fake.ListPackagesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listPackagesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KappClient) ListPackagesCallCount() int {
	fake.listPackagesMutex.RLock()
	defer fake.listPackagesMutex.RUnlock()
	return len(fake.listPackagesArgsForCall)
}

func (fake *KappClient) ListPackagesCalls(stub func() (*v1alpha1b.PackageList, error)) {
	fake.listPackagesMutex.Lock()
	defer fake.listPackagesMutex.Unlock()
	fake.ListPackagesStub = stub
}

func (fake *KappClient) ListPackagesReturns(result1 *v1alpha1b.PackageList, result2 error) {
	fake.listPackagesMutex.Lock()
	defer fake.listPackagesMutex.Unlock()
	fake.ListPackagesStub = nil
	fake.listPackagesReturns = struct {
		result1 *v1alpha1b.PackageList
		result2 error
	}{result1, result2}
}

func (fake *KappClient) ListPackagesReturnsOnCall(i int, result1 *v1alpha1b.PackageList, result2 error) {
	fake.listPackagesMutex.Lock()
	defer fake.listPackagesMutex.Unlock()
	fake.ListPackagesStub = nil
	if fake.listPackagesReturnsOnCall == nil {
		fake.listPackagesReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1b.PackageList
			result2 error
		})
	}
	fake.listPackagesReturnsOnCall[i] = struct {
		result1 *v1alpha1b.PackageList
		result2 error
	}{result1, result2}
}

func (fake *KappClient) UpdatePackageRepository(arg1 *v1alpha1.PackageRepository) error {
	fake.updatePackageRepositoryMutex.Lock()
	ret, specificReturn := fake.updatePackageRepositoryReturnsOnCall[len(fake.updatePackageRepositoryArgsForCall)]
	fake.updatePackageRepositoryArgsForCall = append(fake.updatePackageRepositoryArgsForCall, struct {
		arg1 *v1alpha1.PackageRepository
	}{arg1})
	fake.recordInvocation("UpdatePackageRepository", []interface{}{arg1})
	fake.updatePackageRepositoryMutex.Unlock()
	if fake.UpdatePackageRepositoryStub != nil {
		return fake.UpdatePackageRepositoryStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updatePackageRepositoryReturns
	return fakeReturns.result1
}

func (fake *KappClient) UpdatePackageRepositoryCallCount() int {
	fake.updatePackageRepositoryMutex.RLock()
	defer fake.updatePackageRepositoryMutex.RUnlock()
	return len(fake.updatePackageRepositoryArgsForCall)
}

func (fake *KappClient) UpdatePackageRepositoryCalls(stub func(*v1alpha1.PackageRepository) error) {
	fake.updatePackageRepositoryMutex.Lock()
	defer fake.updatePackageRepositoryMutex.Unlock()
	fake.UpdatePackageRepositoryStub = stub
}

func (fake *KappClient) UpdatePackageRepositoryArgsForCall(i int) *v1alpha1.PackageRepository {
	fake.updatePackageRepositoryMutex.RLock()
	defer fake.updatePackageRepositoryMutex.RUnlock()
	argsForCall := fake.updatePackageRepositoryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KappClient) UpdatePackageRepositoryReturns(result1 error) {
	fake.updatePackageRepositoryMutex.Lock()
	defer fake.updatePackageRepositoryMutex.Unlock()
	fake.UpdatePackageRepositoryStub = nil
	fake.updatePackageRepositoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *KappClient) UpdatePackageRepositoryReturnsOnCall(i int, result1 error) {
	fake.updatePackageRepositoryMutex.Lock()
	defer fake.updatePackageRepositoryMutex.Unlock()
	fake.UpdatePackageRepositoryStub = nil
	if fake.updatePackageRepositoryReturnsOnCall == nil {
		fake.updatePackageRepositoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updatePackageRepositoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *KappClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createInstalledPackageMutex.RLock()
	defer fake.createInstalledPackageMutex.RUnlock()
	fake.createPackageRepositoryMutex.RLock()
	defer fake.createPackageRepositoryMutex.RUnlock()
	fake.deletePackageRepositoryMutex.RLock()
	defer fake.deletePackageRepositoryMutex.RUnlock()
	fake.getAppCRMutex.RLock()
	defer fake.getAppCRMutex.RUnlock()
	fake.getClientMutex.RLock()
	defer fake.getClientMutex.RUnlock()
	fake.getInstalledPackageMutex.RLock()
	defer fake.getInstalledPackageMutex.RUnlock()
	fake.getPackageByNameMutex.RLock()
	defer fake.getPackageByNameMutex.RUnlock()
	fake.getPackageRepositoryMutex.RLock()
	defer fake.getPackageRepositoryMutex.RUnlock()
	fake.listInstalledPackagesMutex.RLock()
	defer fake.listInstalledPackagesMutex.RUnlock()
	fake.listPackageRepositoriesMutex.RLock()
	defer fake.listPackageRepositoriesMutex.RUnlock()
	fake.listPackageVersionsMutex.RLock()
	defer fake.listPackageVersionsMutex.RUnlock()
	fake.listPackagesMutex.RLock()
	defer fake.listPackagesMutex.RUnlock()
	fake.updatePackageRepositoryMutex.RLock()
	defer fake.updatePackageRepositoryMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *KappClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ kappclient.Client = new(KappClient)
